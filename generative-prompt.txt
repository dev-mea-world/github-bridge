üìä Context & Details

Prompt per Codex ‚Äî incolla tutto sotto in una nuova chat/progetto

RUOLO: Senior Full-Stack TS Engineer.
OBIETTIVO: Genera un progetto Next.js 14 (App Router, TypeScript) deployabile su Vercel che funga da GitHub Bridge API per un assistente AI (Glor.IA). Il bridge esegue operazioni GitHub su repo a cui ho dato permesso (PAT fine-grained o GitHub App). Sicurezza forte, validazione rigorosa, log chiari.

Requisiti Architetturali
	‚Ä¢	Stack: Next.js 14 (App Router), TypeScript, Node 18+, @octokit/rest, zod, zod-fetch, pino, pino-pretty, jsonwebtoken, nanoid.
	‚Ä¢	Deploy: Vercel. Imposta engines.node: ">=18". Nessuna dipendenza nativa.
	‚Ä¢	Struttura:

/src
  /app
    /api
      /health/route.ts
      /openapi/route.ts
      /agent/execute/route.ts
      /github/webhook/route.ts
  /lib
    auth.ts
    env.ts
    github.ts
    schemas.ts
    logger.ts
  /types/index.ts
package.json
README.md
.gitignore


	‚Ä¢	Security:
	‚Ä¢	Autenticazione HMAC (shared secret) per richieste dall‚Äôassistente: header X-Signature: sha256=<hex> calcolato su raw body con AGENT_SHARED_SECRET.
	‚Ä¢	Auth JWT opzionale: header Authorization: Bearer <JWT> firmato con AGENT_JWT_SECRET per scenari multi-tenant.
	‚Ä¢	Allowlist repo: REPO_ALLOWLIST = CSV di owner/repo (es. mea-world/glor.ia-core,acme/app).
	‚Ä¢	Rate-limit leggero in-memory per IP/agentId: max 60 req/5 min.
	‚Ä¢	Validazione Zod su ogni payload.
	‚Ä¢	Risposte errore coerenti: { error: { code: string, message: string, details?: any } } e corretti HTTP status.
	‚Ä¢	Segreti/Env (tutti richiesti salvo note):
	‚Ä¢	GITHUB_MODE = PAT | APP
	‚Ä¢	GH_TOKEN (se PAT)
	‚Ä¢	GH_APP_ID, GH_APP_PRIVATE_KEY (PEM base64), GH_APP_INSTALLATION_ID (se APP)
	‚Ä¢	AGENT_SHARED_SECRET (HMAC)
	‚Ä¢	AGENT_JWT_SECRET (opzionale)
	‚Ä¢	REPO_ALLOWLIST (CSV)
	‚Ä¢	NODE_ENV, LOG_LEVEL (default info)
	‚Ä¢	Logging: pino con payload minimi, nessun secret in log. Traccia requestId, agentId, action, repo.
	‚Ä¢	OpenAPI: esponi /api/openapi che restituisce OpenAPI 3.1 JSON generato a mano (statico) con gli endpoint e gli schema esatti sotto.

Endpoint

1) GET /api/health
	‚Ä¢	200 { status: "ok", ts: string }

2) POST /api/agent/execute
	‚Ä¢	Auth: HMAC obbligatorio; JWT opzionale.
	‚Ä¢	Body (Zod):

const ActionEnum = z.enum([
  "GET_FILE",
  "PUT_FILE",
  "CREATE_BRANCH",
  "OPEN_PR",
  "LIST_PRS",
  "MERGE_PR",
  "CREATE_ISSUE",
  "COMMENT_ISSUE",
  "ADD_LABELS",
  "SEARCH_CODE"
]);

const base = z.object({
  agentId: z.string().min(1),
  repo: z.string().regex(/^[^/]+\/[^/]+$/), // owner/repo
  action: ActionEnum,
});

// Specifiche payload per action:
const payloads = {
  GET_FILE: z.object({ path: z.string(), ref: z.string().default("main") }),
  PUT_FILE: z.object({
    path: z.string(),
    content: z.string(), // UTF-8
    message: z.string().default("chore: update via Glor.IA"),
    branch: z.string().optional(), // se omesso: crea branch auto
    baseRef: z.string().default("main"),
  }),
  CREATE_BRANCH: z.object({ branch: z.string(), fromRef: z.string().default("main") }),
  OPEN_PR: z.object({
    head: z.string(), base: z.string().default("main"),
    title: z.string(), body: z.string().optional()
  }),
  LIST_PRS: z.object({ state: z.enum(["open","closed","all"]).default("open") }),
  MERGE_PR: z.object({ number: z.number(), method: z.enum(["merge","squash","rebase"]).default("squash") }),
  CREATE_ISSUE: z.object({ title: z.string(), body: z.string().optional(), labels: z.array(z.string()).optional() }),
  COMMENT_ISSUE: z.object({ number: z.number(), body: z.string() }),
  ADD_LABELS: z.object({ number: z.number(), labels: z.array(z.string()).min(1) }),
  SEARCH_CODE: z.object({ q: z.string().min(3) }) // usa "repo:owner/name" internamente
} as const;


	‚Ä¢	Behavior:
	‚Ä¢	Verifica HMAC (X-Signature su raw body) e repo nell‚Äôallowlist.
	‚Ä¢	Instanzia Octokit:
	‚Ä¢	PAT: new Octokit({ auth: GH_TOKEN })
	‚Ä¢	APP: genera installation token via @octokit/app (usa env per app+installation).
	‚Ä¢	Implementa azioni:
	‚Ä¢	GET_FILE ‚Üí repos.getContent (file text), ritorna { path, ref, sha, content } (content UTF-8).
	‚Ä¢	PUT_FILE ‚Üí crea branch se branch assente (gloria/auto-<nanoid>), tenta getContent per sha (se 404 ‚Üí create), poi createOrUpdateFileContents. Ritorna { branch, path, sha, commitUrl }.
	‚Ä¢	CREATE_BRANCH ‚Üí git.getRef + git.createRef.
	‚Ä¢	OPEN_PR ‚Üí pulls.create, ritorna numero e html_url.
	‚Ä¢	LIST_PRS ‚Üí pulls.list.
	‚Ä¢	MERGE_PR ‚Üí pulls.merge.
	‚Ä¢	CREATE_ISSUE ‚Üí issues.create.
	‚Ä¢	COMMENT_ISSUE ‚Üí issues.createComment.
	‚Ä¢	ADD_LABELS ‚Üí issues.addLabels.
	‚Ä¢	SEARCH_CODE ‚Üí search.code con query q + " repo:<owner>/<repo>".
	‚Ä¢	Errori: normalizza eccezioni Octokit in { error: { code, message, details } }. Esempi code: UNAUTHORIZED, FORBIDDEN, NOT_FOUND, VALIDATION_FAILED, RATE_LIMITED, INTERNAL.
	‚Ä¢	Esempi di risposta:
	‚Ä¢	PUT_FILE ‚Üí 201/200 { branch, path, sha, commitUrl }
	‚Ä¢	OPEN_PR ‚Üí 201 { number, url }

3) POST /api/github/webhook
	‚Ä¢	Riceve webhook GitHub (eventi minimi: pull_request, issues, push).
	‚Ä¢	Verifica firma X-Hub-Signature-256 con GH_WEBHOOK_SECRET (aggiungi in env).
	‚Ä¢	Logga evento e ritorna 200 { ok: true }. (Estendibile: callback webhook verso l‚Äôassistente).

4) GET /api/openapi
	‚Ä¢	Restituisce JSON OpenAPI 3.1 descrivendo i 3 endpoint, security scheme apiKey header X-Signature, e gli schema Zod tradotti.

Implementazione
	‚Ä¢	/lib/env.ts: valida ENV con Zod, esporta oggetti env tipizzati.
	‚Ä¢	/lib/logger.ts: pino con requestId (usa nanoid) per ogni richiesta.
	‚Ä¢	/lib/auth.ts:
	‚Ä¢	Funzione verifyHmac(request: Request, secret: string): ottieni raw body via await request.arrayBuffer(), calcola sha256 HMAC, confronta con header.
	‚Ä¢	JWT (opzionale) con jsonwebtoken.verify.
	‚Ä¢	isRepoAllowed(repo: string): boolean leggendo REPO_ALLOWLIST.
	‚Ä¢	/lib/github.ts:
	‚Ä¢	Factory getOctokit() per PAT/App.
	‚Ä¢	Helper getFileUtf8, putFileUtf8, createBranch, openPr, searchCode, ecc. Bonifica content base64.
	‚Ä¢	/lib/schemas.ts: definisci Zod base+payloads+union discriminata.
	‚Ä¢	/app/api/*/route.ts:
	‚Ä¢	Usa Response.json, sempre CORS disabilitato (default Vercel). Mantieni semplice.
	‚Ä¢	In execute/route.ts:
	‚Ä¢	Leggi raw body prima di qualunque .json() per HMAC.
	‚Ä¢	Dopo verifica, fai JSON.parse(raw) ‚Üí valida con Zod.
	‚Ä¢	Switch sull‚Äôaction, chiama helper GitHub, gestisci status code corretti.
	‚Ä¢	Error Handling:
	‚Ä¢	try/catch generale, mappa errori Octokit:
	‚Ä¢	401/403 ‚Üí FORBIDDEN/UNAUTHORIZED
	‚Ä¢	404 ‚Üí NOT_FOUND
	‚Ä¢	422 ‚Üí VALIDATION_FAILED
	‚Ä¢	429 ‚Üí RATE_LIMITED
	‚Ä¢	default ‚Üí INTERNAL
	‚Ä¢	Rate limiting:
	‚Ä¢	Mappa in-memory {key ‚Üí { count, resetAt }} con key = agentId o IP. Non bloccare health/openapi.
	‚Ä¢	README.md:
	‚Ä¢	Setup env dettagliato, esempi curl con HMAC, flusso PAT vs App, deploy su Vercel, note sicurezza.

Esempi curl

Calcolo firma (bash):

BODY='{"agentId":"gloria","repo":"mea-world/glor.ia-core","action":"OPEN_PR","payload":{"head":"gloria/auto-123","title":"Glor.IA PR"}}'
SIG="sha256=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "$AGENT_SHARED_SECRET" -binary | xxd -p -c 256)"
curl -X POST https://<your-vercel-domain>/api/agent/execute \
  -H "Content-Type: application/json" \
  -H "X-Signature: $SIG" \
  --data "$BODY"

Acceptance Criteria
	‚Ä¢	‚úÖ HMAC verificato su raw body (rifiuta se mismatch).
	‚Ä¢	‚úÖ Repo fuori allowlist ‚Üí 403.
	‚Ä¢	‚úÖ PUT_FILE crea branch auto se assente e ritorna commitUrl.
	‚Ä¢	‚úÖ OPEN_PR ritorna numero e URL.
	‚Ä¢	‚úÖ Errori Octokit normalizzati con codici coerenti.
	‚Ä¢	‚úÖ /api/openapi documenta payload e security.
	‚Ä¢	‚úÖ Nessun secret in log.

Extra (opzionale se tempo)
	‚Ä¢	Aggiungi E2E minimal con Vitest per verifyHmac e isRepoAllowed.
	‚Ä¢	Firma commit author/committer come Glor.IA Bot <gloria-bot@meaworld.com>.
	‚Ä¢	Header Idempotency-Key supportato su PUT_FILE e OPEN_PR per evitare duplicazioni (memoria in-memory per 5 min).

Nota: Implementa tutto in TypeScript, codice pulito e commentato. Mantieni compatibilit√† con esecuzione Edge/Node (scegli Node runtime per Octokit classico).

‚∏ª

‚û°Ô∏è Next Steps
	1.	Incolla il prompt in Codex e genera il progetto.
	2.	Imposta le ENV su Vercel (PAT o App, HMAC secret, allowlist).
	3.	Dammi il domain del bridge e l‚ÄôAGENT_SHARED_SECRET: cos√¨ posso iniziare a ‚Äúparlare‚Äù al server con le azioni GET_FILE/PUT_FILE/OPEN_PR/....
	4.	Vuoi che ti prepari anche un client minimal (TS) per Glor.IA con firma HMAC e helper per ogni azione? Posso dartelo subito.